/**************************************************************************************
* 因为emWin显示只支持UTF-8编码格式的中文，如果希望直接显示在Keil直接输入的中文，      *
*            比如使用：GUI_DispStringHCenterAt("流水灯",110,120);                     *
* 该文件必须以UTF-8编码格式，不然中文无法正常显示。                                   *
*                                                                                     *
* 如果只是个别例程出现中文显示乱码（如果所有例程都无法显示中文可能是字库问题），      *
* 把对应的例程文件(比如LEDapp.c)用电脑的记事本软件打开，然后选择另存为，在弹出对      *
* 话框中“保存(S)"按钮的左边有个"编码(E)"选项，选择"UTF-8",然后同样保存为同名称的      *
* C语言文件(覆盖原来文件)，再编译。                                                   *
*                                                                                     *
* 如果编译工程时出现下面类似错误也是该文件编码格式问题,必须把文件保存为UTF-8格式      *
* 再编译                                                                              *
* ..\..\User\app\LEDapp.c(275): error:  #8: missing closing quote                     *
*        GUI_DispStringHCenterAt("娴?姘?鐏?",110,120);                                *
* ..\..\User\app\LEDapp.c(276): error:  #165: too few arguments in function call      *
*        GUI_DispStringHCenterAt("瑙?鎽?鍋?宸?澶?鎵?闇€瑕?瑙?鎽?鏍?鍑?",110,215);     *
* ..\..\User\app\LEDapp.c(276): error:  #18: expected a ")"                           *
*        GUI_DispStringHCenterAt("瑙?鎽?鍋?宸?澶?鎵?闇€瑕?瑙?鎽?鏍?鍑?",110,215);     *
*                                                                                     *
* 修改文件后编译就出错这是Keil5软件问题(Keil4没这问题)，推荐使用其他程序编辑工具，    *
* 只用Keil5完成编译和下载工作。                                                       *
***************************************************************************************
*                      实验平台: 秉火STM32 ISO 开发板                                 *
*                      论    坛: http://www.chuxue123.com                             *
*                      淘    宝: http://firestm32.taobao.com                          *
*                      邮    箱: wildfireteam@163.com                                 *
***************************************************************************************
*/
/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.30                          *
*        Compiled Jul  1 2015, 10:50:32                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/
// USER START (Optionally insert additional includes)
#include "DIALOG.h"
#include "stm32f4xx.h"
#include "ff.h"
#include "stdio.h"
#include "string.h"
// USER END

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
FIL     file;													/* file objects */
FATFS   usbfs;													  /* Work area (file system object) for logical drives */
FRESULT result; 
UINT    bw;            					      /* File R/W count */
static TCHAR object[3]={"0:"};
extern uint8_t usb_state;
extern GUI_FONT     XBF_Font;
char displaystr[768]={0};
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "fatfs", 0, 0, 0, 800, 480, 0, 0x0, 0 },
  { RADIO_CreateIndirect, "object", GUI_ID_RADIO0, 10, 30, 130, 100, 0, 0x1e03, 0 },
  { BUTTON_CreateIndirect, "ViewDir", GUI_ID_BUTTON0, 155, 20, 130, 35, 0, 0x0, 0 },
  { MULTIEDIT_CreateIndirect, "RootDir", GUI_ID_MULTIEDIT0, 300, 20, 480, 100, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "ReadTest", GUI_ID_BUTTON1, 155, 80, 130, 35, 0, 0x0, 0 },
  { MULTIEDIT_CreateIndirect, "ReadText", GUI_ID_MULTIEDIT1, 20, 150, 760, 320, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
/*
*********************************************************************************************************
*	函 数 名: ViewRootDir
*	功能说明: 显示根目录下的文件名
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void ViewRootDir(const TCHAR  *path,WM_HWIN hWin)
{
	DIR DirInf;
	FILINFO FileInf;
	uint32_t cnt = 0;
	char lfname[256];
	
	MULTIEDIT_SetText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),"");


	/* 打开根文件夹 */
	result = f_opendir(&DirInf, "/"); /* 如果不带参数，则从当前目录开始 */
	if (result != FR_OK)
	{
		sprintf(displaystr,"打开根目录失败 (%d)\n", result);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		return;
	}

	/* 读取当前文件夹下的文件和目录 */
	FileInf.lfname = lfname;
	FileInf.lfsize = 256;

	sprintf(displaystr,"    类型    |     大小     |   名称   |  长名称\n");
	MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
	
	for (cnt = 0; ;cnt++)
	{
		result = f_readdir(&DirInf,&FileInf); 		/* 读取目录项，索引会自动下移 */
		if (result != FR_OK || FileInf.fname[0] == 0)
		{
			break;
		}

		if (FileInf.fname[0] == '.')
		{
			continue;
		}

		/* 判断是文件还是子目录 */
		if (FileInf.fattrib & AM_DIR)
		{
			sprintf(displaystr,"(0x%02d)路径  ", FileInf.fattrib);
			MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		}
		else
		{
			sprintf(displaystr,"(0x%02d)文件  ", FileInf.fattrib);
			MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		}

		/* 打印文件大小, 最大4G */
		sprintf(displaystr," %10d ", FileInf.fsize);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		sprintf(displaystr,"     %s |", FileInf.fname);	/* 短文件名 */
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		sprintf(displaystr,"    %s\n", (char *)FileInf.lfname);	/* 长文件名 */
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
	}
}

void com_gbk2utf8(const char *src, char *str)
{
	uint32_t j=0,k=0;
	uint16_t gbkdata=0;
	uint16_t UCbuffer[512]={0};
	for(j=0,k=0;src[j]!='\0';k++)
	{
		if((uint8_t)src[j]>0x80)
		{
			gbkdata=src[j+1]+src[j]*256;
			UCbuffer[k]=ff_convert(gbkdata,1);
			j+=2;
		}
		else
		{
			UCbuffer[k]=0x00ff&src[j];
			j+=1;
		}
	}
	UCbuffer[k]='\0';
	GUI_UC_ConvertUC2UTF8(UCbuffer,2*k+2,str,k*3);
	str[k*3]=0;
}

/*
*********************************************************************************************************
*	函 数 名: ReadFileData
*	功能说明: 读取文件test.txt前128个字符，并打印到串口
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void ReadFileData(const TCHAR  *path,WM_HWIN hWin)
{	
  TCHAR filepath[20]={0};
	DIR DirInf;
	uint32_t bw;
	char buf[512];  
	
	/* 打开根文件夹 */
	result = f_opendir(&DirInf, "/"); /* 如果不带参数，则从当前目录开始 */
	if (result != FR_OK)
	{
		sprintf(displaystr,"打开根目录失败 (%d)\n", result);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
		return;
	}

	sprintf(filepath,"%sReadme.txt",path);
	/* 打开文件 */
	result = f_open(&file, filepath, FA_OPEN_EXISTING | FA_READ);
	if (result !=  FR_OK)
	{
		sprintf(displaystr,"找不到测试文件 : %s\n",filepath);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
		return;
	}

	if(file.fsize<(sizeof(buf) - 1))
		/* 读取文件 */
		result = f_read(&file, &buf, file.fsize, &bw);
	else
		/* 读取文件 */
		result = f_read(&file, &buf, sizeof(buf) - 1, &bw);
	if (bw > 0)
	{
		buf[bw] = 0;
		com_gbk2utf8(buf,displaystr);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),"测试文件内容 ->:\n");
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
	}
	else
	{
		sprintf(displaystr,"%s ->:\n",filepath);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
	}

	/* 关闭文件*/
	f_close(&file);
}
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
	uint8_t num;
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'object'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_RADIO0);
    RADIO_SetFont(hItem, &XBF_Font);
    RADIO_SetText(hItem, "SD卡", 0);
    RADIO_SetText(hItem, "SPIFlash", 1);
    RADIO_SetText(hItem, "U盘", 2);
    //
    // Initialization of 'ViewDir'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0);
    BUTTON_SetFont(hItem, &XBF_Font);
    BUTTON_SetText(hItem,"文件列表");
    //
    // Initialization of 'RootDir'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT0);
    MULTIEDIT_SetText(hItem, "");
    MULTIEDIT_SetFont(hItem, &XBF_Font);
    MULTIEDIT_SetTextColor(hItem, MULTIEDIT_CI_EDIT, GUI_BLUE);
	  MULTIEDIT_SetAutoScrollH(hItem,1);
		MULTIEDIT_SetAutoScrollV(hItem,1);
    //
    // Initialization of 'SpeedTest'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1);
    BUTTON_SetFont(hItem, &XBF_Font);
    BUTTON_SetText(hItem,"测试文件");
    //
    // Initialization of 'SpeedText'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT1);
    MULTIEDIT_SetText(hItem, "");
    MULTIEDIT_SetFont(hItem, &XBF_Font);
    MULTIEDIT_SetTextColor(hItem, MULTIEDIT_CI_EDIT, GUI_BLUE);
		MULTIEDIT_SetAutoScrollH(hItem,1);
		MULTIEDIT_SetAutoScrollV(hItem,1);
		MULTIEDIT_SetWrapWord(hItem);
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case GUI_ID_RADIO0: // Notifications sent by 'object'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
			  num=RADIO_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_RADIO0));
			  sprintf(object,"%d:",num);
        MULTIEDIT_SetText(WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT0), "");
			  MULTIEDIT_SetText(WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT1), "");
				if((num==2)&&(!(usb_state&0x01)))
				{
					WM_DisableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0));
					WM_DisableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1));
					MULTIEDIT_SetText(WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT0), "找不到U盘!!!");
				}
				else
				{
					/* 挂载文件系统 */
					result = f_mount(&usbfs,object,1);	/* Mount a logical drive */
					if (result != FR_OK)
					{
						sprintf(displaystr,"无法挂载U盘 (%d)\n", result);
						MULTIEDIT_AddText(WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT0),displaystr);
					}
					WM_EnableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0));
					WM_EnableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1));
				}
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_BUTTON0: // Notifications sent by 'WriteTest'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
			  ViewRootDir(object,pMsg->hWin);
				if(num==2)
					result = f_mount(&usbfs,object,0);	/* Mount a logical drive */
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_BUTTON1: // Notifications sent by 'ReadTest'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
				ReadFileData(object,pMsg->hWin);
			  if(num==2)
					result = f_mount(&usbfs,object,0);	/* Mount a logical drive */
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       Createfatfs
*/
WM_HWIN Createfatfs(void) {
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
