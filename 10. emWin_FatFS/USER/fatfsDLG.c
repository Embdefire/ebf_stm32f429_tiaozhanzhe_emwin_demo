/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.30                          *
*        Compiled Jul  1 2015, 10:50:32                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/
// USER START (Optionally insert additional includes)
#include "DIALOG.h"
#include "stm32f4xx.h"
#include "ff.h"
#include "stdio.h"
// USER END

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
FIL     file;													/* file objects */
FATFS   fs;													  /* Work area (file system object) for logical drives */
FRESULT result; 
UINT    bw;            					      /* File R/W count */
static uint8_t bar=0;
static TCHAR object[3]={"0:"};
extern uint8_t usb_state;
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "fatfs", 0, 0, 0, 800, 480, 0, 0x0, 0 },
  { RADIO_CreateIndirect, "object", GUI_ID_RADIO0, 10, 30, 110, 80, 0, 0x1e03, 0 },
  { BUTTON_CreateIndirect, "ViewDir", GUI_ID_BUTTON0, 150, 20, 110, 30, 0, 0x0, 0 },
  { MULTIEDIT_CreateIndirect, "RootDir", GUI_ID_MULTIEDIT0, 300, 20, 450, 150, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "SpeedTest", GUI_ID_BUTTON1, 150, 200, 110, 30, 0, 0x0, 0 },
  { MULTIEDIT_CreateIndirect, "SpeedText", GUI_ID_MULTIEDIT1, 300, 230, 450, 150, 0, 0x0, 0 },
  { PROGBAR_CreateIndirect, "Progbar", GUI_ID_PROGBAR0, 300, 200, 450, 20, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
/*
*********************************************************************************************************
*	函 数 名: ViewRootDir
*	功能说明: 显示根目录下的文件名
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void ViewRootDir(const TCHAR  *path,WM_HWIN hWin)
{
	DIR DirInf;
	FILINFO FileInf;
	uint32_t cnt = 0;
	char lfname[256];
	char displaystr[100]={0};
	
	MULTIEDIT_SetText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),"");
 	/* 挂载文件系统 */
	result = f_mount(&fs,path,1);	/* Mount a logical drive */
	if (result != FR_OK)
	{
		sprintf(displaystr,"fatfs mount fail (%d)\n", result);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		return;
	}

	/* 打开根文件夹 */
	result = f_opendir(&DirInf, "/"); /* 如果不带参数，则从当前目录开始 */
	if (result != FR_OK)
	{
		sprintf(displaystr,"open root directory fail (%d)\n", result);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		return;
	}

	/* 读取当前文件夹下的文件和目录 */
	FileInf.lfname = lfname;
	FileInf.lfsize = 256;

	sprintf(displaystr,"    Type    |     Size     |   Simpligy Name   |  Complete Name\n");
	MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
	
	for (cnt = 0; ;cnt++)
	{
		result = f_readdir(&DirInf,&FileInf); 		/* 读取目录项，索引会自动下移 */
		if (result != FR_OK || FileInf.fname[0] == 0)
		{
			break;
		}

		if (FileInf.fname[0] == '.')
		{
			continue;
		}

		/* 判断是文件还是子目录 */
		if (FileInf.fattrib & AM_DIR)
		{
			sprintf(displaystr,"(0x%02d)Path  ", FileInf.fattrib);
			MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		}
		else
		{
			sprintf(displaystr,"(0x%02d)file  ", FileInf.fattrib);
			MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		}

		/* 打印文件大小, 最大4G */
		sprintf(displaystr," %10d ", FileInf.fsize);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		sprintf(displaystr,"     %s |", FileInf.fname);	/* 短文件名 */
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		sprintf(displaystr,"    %s\n", (char *)FileInf.lfname);	/* 长文件名 */
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
	}

	/* 卸载文件系统 */
	f_mount(&fs,path,0);
}

/* 用于测试读写速度 */
#define TEST_FILE_LEN			(2*1024*1024)	/* 用于测试的文件长度 */
#define BUF_SIZE				  (4*1024)		/* 每次读写SD卡的最大数据长度 */
uint8_t g_TestBuf[BUF_SIZE];
/*
*********************************************************************************************************
*	函 数 名: WriteFileTest
*	功能说明: 测试文件读写速度
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void WriteFileTest(const TCHAR  *path,WM_HWIN hWin)
{
	/* 本函数使用的局部变量占用较多，请修改启动文件，保证堆栈空间够用 */
	DIR DirInf;
	uint32_t i,k;
	uint32_t runtime1,runtime2,timelen;
	uint8_t err = 0;
	char TestFileName[20];
	char displaystr[100]={0};
  bar=0;
	
	for (i = 0; i < sizeof(g_TestBuf); i++)
	{
		g_TestBuf[i] = (i / 512) + '0';
	}
	
	MULTIEDIT_SetText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),"");
  	/* 挂载文件系统 */
	result = f_mount(&fs, path, 1);			/* Mount a logical drive */
	if (result != FR_OK)
	{
		sprintf(displaystr,"fatfs mount fail (%d)\n", result);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
		return;
	}

	/* 打开根文件夹 */
	result = f_opendir(&DirInf, "/"); /* 如果不带参数，则从当前目录开始 */
	if (result != FR_OK)
	{
		sprintf(displaystr,"open root directory fail (%d)\n", result);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
		return;
	}

	/* 打开文件 */
	sprintf(TestFileName, "%sSpeed.txt",path);		/* 每写1次，序号递增 */
	result = f_open(&file, TestFileName, FA_CREATE_ALWAYS | FA_WRITE);

	/* 写一串数据 */
	sprintf(displaystr,"starting write data:%s %dKB ...\n", TestFileName, TEST_FILE_LEN / 1024);
	MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
	
	runtime1 = GUI_GetTime();	/* 读取系统运行时间 */
	for (i = 0; i < TEST_FILE_LEN / BUF_SIZE; i++)
	{
		result = f_write(&file, g_TestBuf, sizeof(g_TestBuf), &bw);
		if (result == FR_OK)
		{
			if (((i + 1) % 8) == 0)
			{
				//sprintf(displaystr,".");
				PROGBAR_SetValue(WM_GetDialogItem(hWin, GUI_ID_PROGBAR0),bar);
				bar++;
				WM_Exec();
			}
		}
		else
		{
			err = 1;
			sprintf(displaystr,"%sfile write error\n", TestFileName);
			MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
			break;
		}
	}
	runtime2 = GUI_GetTime();	/* 读取系统运行时间 */

	if (err == 0)
	{
		timelen = (runtime2 - runtime1);
		sprintf(displaystr," write time : %dms   Average speed : %dB/S (%dKB/S)\n",
			timelen,
			(TEST_FILE_LEN * 1000) / timelen,
			((TEST_FILE_LEN / 1024) * 1000) / timelen);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
	}

	f_close(&file);		/* 关闭文件*/


	/* 开始读文件测试 */
	result = f_open(&file, TestFileName, FA_OPEN_EXISTING | FA_READ);
	if (result !=  FR_OK)
	{
		sprintf(displaystr,"read:open file fail: %s\n", TestFileName);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
		return;
	}

	sprintf(displaystr,"start read data: %dKB ...\n", TEST_FILE_LEN / 1024);
	MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
	runtime1 = GUI_GetTime();	/* 读取系统运行时间 */
	for (i = 0; i < TEST_FILE_LEN / BUF_SIZE; i++)
	{
		result = f_read(&file, g_TestBuf, sizeof(g_TestBuf), &bw);
		if (result == FR_OK)
		{
			if (((i + 1) % 8) == 0)
			{
				//sprintf(displaystr,".");
				PROGBAR_SetValue(WM_GetDialogItem(hWin, GUI_ID_PROGBAR0),bar);
				bar++;
				WM_Exec();
			}

			/* 比较写入的数据是否正确，此语句会导致读卡速度结果降低到 3.5MBytes/S */
			for (k = 0; k < sizeof(g_TestBuf); k++)
			{
				if (g_TestBuf[k] != (k / 512) + '0')
				{
				  	err = 1;
					sprintf(displaystr,"%s read data error\n",TestFileName);
					MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
					break;
				}
			}
			if (err == 1)
			{
				break;
			}
		}
		else
		{
			err = 1;
			sprintf(displaystr,"%s file open fail\n",TestFileName);
			MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
			break;
		}
	}
	runtime2 = GUI_GetTime();	/* 读取系统运行时间 */

	if (err == 0)
	{
		timelen = (runtime2 - runtime1);
		sprintf(displaystr,"  read time : %dms   Average speed : %dB/S (%dKB/S)\n", timelen,
			(TEST_FILE_LEN * 1000) / timelen, ((TEST_FILE_LEN / 1024) * 1000) / timelen);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
	}

	/* 关闭文件*/
	f_close(&file);

	/* 卸载文件系统 */
	 f_mount(&fs, path, 0);
}
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
	uint8_t num;
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'object'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_RADIO0);
    RADIO_SetFont(hItem, GUI_FONT_20B_ASCII);
    RADIO_SetText(hItem, "SD Card", 0);
    RADIO_SetText(hItem, "Spi Flash", 1);
    RADIO_SetText(hItem, "USB", 2);
    //
    // Initialization of 'ViewDir'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0);
    BUTTON_SetFont(hItem, GUI_FONT_20B_ASCII);
    //
    // Initialization of 'RootDir'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT0);
    MULTIEDIT_SetText(hItem, "");
    MULTIEDIT_SetFont(hItem, GUI_FONT_16B_ASCII);
    MULTIEDIT_SetTextColor(hItem, MULTIEDIT_CI_EDIT, GUI_BLUE);
	  MULTIEDIT_SetAutoScrollH(hItem,1);
		MULTIEDIT_SetAutoScrollV(hItem,1);
    //
    // Initialization of 'SpeedTest'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1);
    BUTTON_SetFont(hItem, GUI_FONT_20B_ASCII);
    //
    // Initialization of 'SpeedText'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT1);
    MULTIEDIT_SetText(hItem, "");
    MULTIEDIT_SetFont(hItem, GUI_FONT_16B_ASCII);
    MULTIEDIT_SetTextColor(hItem, MULTIEDIT_CI_EDIT, GUI_BLUE);
		MULTIEDIT_SetAutoScrollH(hItem,1);
		MULTIEDIT_SetAutoScrollV(hItem,1);
		//
    // Initialization of 'Progbar'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_PROGBAR0);
    PROGBAR_SetFont(hItem, GUI_FONT_8X10_ASCII);
		PROGBAR_SetMinMax(hItem,0,127);
		PROGBAR_SetValue(hItem,0);
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case GUI_ID_RADIO0: // Notifications sent by 'object'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
			  num=RADIO_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_RADIO0));
			  sprintf(object,"%d:",num);
        MULTIEDIT_SetText(WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT0), "");
			  MULTIEDIT_SetText(WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT1), "");
			  PROGBAR_SetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_PROGBAR0),0);
				if(num==1)
				{
					WM_DisableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1));
					//WM_EnableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1));
					WM_EnableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0));
				}
				else if((num==2)&&(!(usb_state&0x01)))
				{
					WM_DisableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0));
					WM_DisableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1));
					MULTIEDIT_SetText(WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT0), "U Disk can not find!!!");
				}
				else
				{
					WM_EnableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0));
					WM_EnableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1));
				}
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_BUTTON0: // Notifications sent by 'WriteTest'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
			  ViewRootDir(object,pMsg->hWin);
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_BUTTON1: // Notifications sent by 'ReadTest'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
				WriteFileTest(object,pMsg->hWin);
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       Createfatfs
*/
WM_HWIN Createfatfs(void) {
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
