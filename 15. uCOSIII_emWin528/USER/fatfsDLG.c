/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.30                          *
*        Compiled Jul  1 2015, 10:50:32                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/
// USER START (Optionally insert additional includes)
#include "DIALOG.h"
#include "stm32f4xx.h"
#include "ff.h"
#include "stdio.h"
#include "string.h"
// USER END

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
FIL     file;													/* file objects */
FATFS   usbfs;													  /* Work area (file system object) for logical drives */
FRESULT result; 
UINT    bw;            					      /* File R/W count */
static TCHAR object[3]={"0:"};
extern uint8_t usb_state;
extern GUI_FONT     XBF_Font;
char displaystr[768]={0};
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "fatfs", 0, 0, 0, 800, 480, 0, 0x0, 0 },
  { RADIO_CreateIndirect, "object", GUI_ID_RADIO0, 10, 10, 110, 80, 0, 0x1e03, 0 },
  { BUTTON_CreateIndirect, "ViewDir", GUI_ID_BUTTON0, 150, 20, 110, 30, 0, 0x0, 0 },
  { MULTIEDIT_CreateIndirect, "RootDir", GUI_ID_MULTIEDIT0, 300, 20, 450, 100, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "ReadTest", GUI_ID_BUTTON1, 150, 100, 110, 30, 0, 0x0, 0 },
  { MULTIEDIT_CreateIndirect, "ReadText", GUI_ID_MULTIEDIT1, 20, 150, 760, 320, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
/*
*********************************************************************************************************
*	函 数 名: ViewRootDir
*	功能说明: 显示根目录下的文件名
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void ViewRootDir(const TCHAR  *path,WM_HWIN hWin)
{
	DIR DirInf;
	FILINFO FileInf;
	uint32_t cnt = 0;
	char lfname[256];
	
	MULTIEDIT_SetText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),"");


	/* 打开根文件夹 */
	result = f_opendir(&DirInf, "/"); /* 如果不带参数，则从当前目录开始 */
	if (result != FR_OK)
	{
		sprintf(displaystr,"open root directory fail (%d)\n", result);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		return;
	}

	/* 读取当前文件夹下的文件和目录 */
	FileInf.lfname = lfname;
	FileInf.lfsize = 256;

	sprintf(displaystr,"    Type    |     Size     |   Simpligy Name   |  Complete Name\n");
	MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
	
	for (cnt = 0; ;cnt++)
	{
		result = f_readdir(&DirInf,&FileInf); 		/* 读取目录项，索引会自动下移 */
		if (result != FR_OK || FileInf.fname[0] == 0)
		{
			break;
		}

		if (FileInf.fname[0] == '.')
		{
			continue;
		}

		/* 判断是文件还是子目录 */
		if (FileInf.fattrib & AM_DIR)
		{
			sprintf(displaystr,"(0x%02d)Path  ", FileInf.fattrib);
			MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		}
		else
		{
			sprintf(displaystr,"(0x%02d)file  ", FileInf.fattrib);
			MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		}

		/* 打印文件大小, 最大4G */
		sprintf(displaystr," %10d ", FileInf.fsize);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		sprintf(displaystr,"     %s |", FileInf.fname);	/* 短文件名 */
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
		sprintf(displaystr,"    %s\n", (char *)FileInf.lfname);	/* 长文件名 */
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT0),displaystr);
	}
}

void com_gbk2utf8(const char *src, char *str)
{
	uint32_t j=0,k=0;
	uint16_t gbkdata=0;
	uint16_t UCbuffer[512]={0};
	for(j=0,k=0;src[j]!='\0';k++)
	{
		if((uint8_t)src[j]>0x80)
		{
			gbkdata=src[j+1]+src[j]*256;
			UCbuffer[k]=ff_convert(gbkdata,1);
			j+=2;
		}
		else
		{
			UCbuffer[k]=0x00ff&src[j];
			j+=1;
		}
	}
	UCbuffer[k]='\0';
	GUI_UC_ConvertUC2UTF8(UCbuffer,2*k+2,str,k*3);
	str[k*3]=0;
}

/*
*********************************************************************************************************
*	函 数 名: ReadFileData
*	功能说明: 读取文件test.txt前128个字符，并打印到串口
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void ReadFileData(const TCHAR  *path,WM_HWIN hWin)
{	
  TCHAR filepath[20]={0};
	DIR DirInf;
	uint32_t bw;
	char buf[512];  
	
	/* 打开根文件夹 */
	result = f_opendir(&DirInf, "/"); /* 如果不带参数，则从当前目录开始 */
	if (result != FR_OK)
	{
		sprintf(displaystr,"open root directory fail (%d)\n", result);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
		return;
	}

	sprintf(filepath,"%stestfile.txt",path);
	/* 打开文件 */
	result = f_open(&file, filepath, FA_OPEN_EXISTING | FA_READ);
	if (result !=  FR_OK)
	{
		sprintf(displaystr,"Don't Find File : %s\n",filepath);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
		return;
	}

	if(file.fsize<(sizeof(buf) - 1))
		/* 读取文件 */
		result = f_read(&file, &buf, file.fsize, &bw);
	else
		/* 读取文件 */
		result = f_read(&file, &buf, sizeof(buf) - 1, &bw);
	if (bw > 0)
	{
		buf[bw] = 0;
		com_gbk2utf8(buf,displaystr);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),"testifle ->:\n");
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
	}
	else
	{
		sprintf(displaystr,"%s ->:\n",filepath);
		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
	}

	/* 关闭文件*/
	f_close(&file);
}

///* 用于测试读写速度 */
//#define TEST_FILE_LEN			(2*1024*1024)	/* 用于测试的文件长度 */
//#define BUF_SIZE				  (4*1024)		/* 每次读写SD卡的最大数据长度 */
//uint8_t g_TestBuf[BUF_SIZE];
///*
//*********************************************************************************************************
//*	函 数 名: WriteFileTest
//*	功能说明: 测试文件读写速度
//*	形    参：无
//*	返 回 值: 无
//*********************************************************************************************************
//*/
//static void WriteFileTest(const TCHAR  *path,WM_HWIN hWin)
//{
//	/* 本函数使用的局部变量占用较多，请修改启动文件，保证堆栈空间够用 */
//	DIR DirInf;
//	uint32_t i,k;
//	uint32_t runtime1,runtime2,timelen;
//	uint8_t err = 0;
//	char TestFileName[20];
//	char displaystr[100]={0};
//	static uint8_t s_ucTestSn = 0;
//  bar=0;
//	
//	for (i = 0; i < sizeof(g_TestBuf); i++)
//	{
//		g_TestBuf[i] = (i / 512) + '0';
//	}
//	
//	MULTIEDIT_SetText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),"");

//	/* 打开根文件夹 */
//	result = f_opendir(&DirInf, "/"); /* 如果不带参数，则从当前目录开始 */
//	if (result != FR_OK)
//	{
//		sprintf(displaystr,"open root directory fail (%d)\n", result);
//		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
//		return;
//	}

//	/* 打开文件 */
//	sprintf(TestFileName, "%sSpeed%02d.txt",path, s_ucTestSn++);		/* 每写1次，序号递增 */
//	result = f_open(&file, TestFileName, FA_CREATE_ALWAYS | FA_WRITE);

//	/* 写一串数据 */
//	sprintf(displaystr,"starting write data:%s %dKB ...\n", TestFileName, TEST_FILE_LEN / 1024);
//	MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
//	
//	runtime1 = GUI_GetTime();	/* 读取系统运行时间 */
//	for (i = 0; i < TEST_FILE_LEN / BUF_SIZE; i++)
//	{
//		result = f_write(&file, g_TestBuf, sizeof(g_TestBuf), &bw);
//		if (result == FR_OK)
//		{
//			if (((i + 1) % 8) == 0)
//			{
//				//sprintf(displaystr,".");
//				PROGBAR_SetValue(WM_GetDialogItem(hWin, GUI_ID_PROGBAR0),bar);
//				bar++;
//				WM_Exec();
//			}
//		}
//		else
//		{
//			err = 1;
//			sprintf(displaystr,"%sfile write error\n", TestFileName);
//			MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
//			break;
//		}
//	}
//	runtime2 = GUI_GetTime();	/* 读取系统运行时间 */

//	if (err == 0)
//	{
//		timelen = (runtime2 - runtime1);
//		sprintf(displaystr," write time : %dms   Average speed : %dB/S (%dKB/S)\n",
//			timelen,
//			(TEST_FILE_LEN * 1000) / timelen,
//			((TEST_FILE_LEN / 1024) * 1000) / timelen);
//		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
//	}

//	f_close(&file);		/* 关闭文件*/


//	/* 开始读文件测试 */
//	result = f_open(&file, TestFileName, FA_OPEN_EXISTING | FA_READ);
//	if (result !=  FR_OK)
//	{
//		sprintf(displaystr,"read:open file fail: %s\n", TestFileName);
//		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
//		return;
//	}

//	sprintf(displaystr,"start read data: %dKB ...\n", TEST_FILE_LEN / 1024);
//	MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
//	runtime1 = GUI_GetTime();	/* 读取系统运行时间 */
//	for (i = 0; i < TEST_FILE_LEN / BUF_SIZE; i++)
//	{
//		result = f_read(&file, g_TestBuf, sizeof(g_TestBuf), &bw);
//		if (result == FR_OK)
//		{
//			if (((i + 1) % 8) == 0)
//			{
//				//sprintf(displaystr,".");
//				PROGBAR_SetValue(WM_GetDialogItem(hWin, GUI_ID_PROGBAR0),bar);
//				bar++;
//				WM_Exec();
//			}

//			/* 比较写入的数据是否正确，此语句会导致读卡速度结果降低到 3.5MBytes/S */
//			for (k = 0; k < sizeof(g_TestBuf); k++)
//			{
//				if (g_TestBuf[k] != (k / 512) + '0')
//				{
//				  	err = 1;
//					sprintf(displaystr,"%s read data error\n",TestFileName);
//					MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
//					break;
//				}
//			}
//			if (err == 1)
//			{
//				break;
//			}
//		}
//		else
//		{
//			err = 1;
//			sprintf(displaystr,"%s file open fail\n",TestFileName);
//			MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
//			break;
//		}
//	}
//	runtime2 = GUI_GetTime();	/* 读取系统运行时间 */

//	if (err == 0)
//	{
//		timelen = (runtime2 - runtime1);
//		sprintf(displaystr,"  read time : %dms   Average speed : %dB/S (%dKB/S)\n", timelen,
//			(TEST_FILE_LEN * 1000) / timelen, ((TEST_FILE_LEN / 1024) * 1000) / timelen);
//		MULTIEDIT_AddText(WM_GetDialogItem(hWin, GUI_ID_MULTIEDIT1),displaystr);
//	}

//	/* 关闭文件*/
//	f_close(&file);

//}
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
	uint8_t num;
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'object'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_RADIO0);
    RADIO_SetFont(hItem, GUI_FONT_20B_ASCII);
    RADIO_SetText(hItem, "SD Card", 0);
    RADIO_SetText(hItem, "Spi Flash", 1);
    RADIO_SetText(hItem, "USB", 2);
    //
    // Initialization of 'ViewDir'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0);
    BUTTON_SetFont(hItem, GUI_FONT_20B_ASCII);
    //
    // Initialization of 'RootDir'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT0);
    MULTIEDIT_SetText(hItem, "");
    MULTIEDIT_SetFont(hItem, GUI_FONT_16B_ASCII);
    MULTIEDIT_SetTextColor(hItem, MULTIEDIT_CI_EDIT, GUI_BLUE);
	  MULTIEDIT_SetAutoScrollH(hItem,1);
		MULTIEDIT_SetAutoScrollV(hItem,1);
    //
    // Initialization of 'SpeedTest'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1);
    BUTTON_SetFont(hItem, GUI_FONT_20B_ASCII);
    //
    // Initialization of 'SpeedText'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT1);
    MULTIEDIT_SetText(hItem, "");
    MULTIEDIT_SetFont(hItem, &XBF_Font);
    MULTIEDIT_SetTextColor(hItem, MULTIEDIT_CI_EDIT, GUI_BLUE);
		MULTIEDIT_SetAutoScrollH(hItem,1);
		MULTIEDIT_SetAutoScrollV(hItem,1);
		MULTIEDIT_SetWrapWord(hItem);
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case GUI_ID_RADIO0: // Notifications sent by 'object'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
			  num=RADIO_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_RADIO0));
			  sprintf(object,"%d:",num);
        MULTIEDIT_SetText(WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT0), "");
			  MULTIEDIT_SetText(WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT1), "");
				if((num==2)&&(!(usb_state&0x01)))
				{
					WM_DisableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0));
					WM_DisableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1));
					MULTIEDIT_SetText(WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT0), "U Disk can not find!!!");
				}
				else
				{
					/* 挂载文件系统 */
					result = f_mount(&usbfs,object,1);	/* Mount a logical drive */
					if (result != FR_OK)
					{
						sprintf(displaystr,"usb fatfs mount fail (%d)\n", result);
						MULTIEDIT_AddText(WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT0),displaystr);
					}
					WM_EnableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0));
					WM_EnableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1));
				}
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_BUTTON0: // Notifications sent by 'WriteTest'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
			  ViewRootDir(object,pMsg->hWin);
				if(num==2)
					result = f_mount(&usbfs,object,0);	/* Mount a logical drive */
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_BUTTON1: // Notifications sent by 'ReadTest'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
				ReadFileData(object,pMsg->hWin);
			  if(num==2)
					result = f_mount(&usbfs,object,0);	/* Mount a logical drive */
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
//	case WM_PAINT:
//		GUI_SetFont(&XBF_Font);
//		GUI_SetTextMode(GUI_TM_TRANS);
//	  GUI_SetColor(GUI_BLUE);
//		GUI_DispStringAt("XBF中文格式显示",10,100);			
//	break;
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       Createfatfs
*/
WM_HWIN Createfatfs(void) {
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
